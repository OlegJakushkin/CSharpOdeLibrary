{"name":"CSharp ODE Library","tagline":"Simple C# ODE Solver Library","body":"CSharp Ode Library\r\n================\r\nCSharpOdeLibrary\r\n\r\nSimple C# ODE Solver Library (Wrapper around Boost.OdeInt). \r\n\r\nSay you want to define ODE system like that:\r\n```CSharp\r\n           var lorenz = new LambdaOde\r\n            {\r\n                From = 0,\r\n                To = 25,\r\n                Step = 0.1,\r\n                InitialConditions = new StateType(new[] { 10, 1.0, 1.0 }),\r\n                OdeObserver = (x, t) => Console.WriteLine(\"{0} : {1} : {2}\", x[0], x[1], x[2]),\r\n                OdeSystem =\r\n                (x, dxdt, t) => {\r\n                    const double sigma = 10.0;\r\n                    const double r = 28.0;\r\n                    const double b = 8.0 / 3.0;\r\n                    dxdt[0] = sigma * (x[1] - x[0]);\r\n                    dxdt[1] = r * x[0] - x[1] - x[0] * x[2];\r\n                    dxdt[2] = -b * x[2] + x[0] * x[1];\r\n                }\r\n            };\r\n```\r\n\r\nOr as Your Own Class:\r\n```CSharp\r\nusing System;\r\nusing OdeLibrary;\r\n\r\nnamespace OdeTest\r\n{\r\n    class LorenzOde : Ode\r\n    {\r\n        protected override void observer(StateType x, double t)\r\n        {\r\n            if (x.Capacity != 0)\r\n            {\r\n                Console.WriteLine(\"{0} : {1} : {2}\", x[0], x[1], x[2]);\r\n            }\r\n        }\r\n\r\n        protected override void system(StateType x, StateType dxdt, double t)\r\n        {\r\n            const double sigma = 10.0;\r\n            const double r = 28.0;\r\n            const double b = 8.0/3.0;\r\n            dxdt[0] = sigma * (x[1] - x[0]);\r\n            dxdt[1] = r * x[0] - x[1] - x[0] * x[2];\r\n            dxdt[2] = -b * x[2] + x[0] * x[1];\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nor with **Complex Numbers**:\r\n```\r\nvar stuartLandauOscillator = new ComplexLambdaOde\r\n{\r\n    InitialConditions =  new ComplexStateType {new Complex(1, 0)},\r\n    OdeObserver = (x, t) => Console.WriteLine(\"{0}\", x[0]),\r\n    OdeSystem =\r\n    (x, dxdt, t) =>\r\n    {\r\n        dxdt[0] = complexEta * x[0] - (complexAlpha *  x[0].Norm()) * x[0];\r\n    }\r\n\r\n};\r\n```\r\n\r\n\r\nYou can do it with our library assistance.\r\n\r\nSimple, Fast, Modern, C# ODE Solver\r\n===================================\r\nWe use Boost.OdeInt as C++ code base. Provide simple C++ wrapper around it. Use SWIG to generate bride between C++ and C#. And provide simple modern interface for its use.\r\n\r\nMotivation Exaple (Console sample):\r\n```CSharp\r\nusing System;\r\nusing OdeLibrary;\r\n\r\nnamespace OdeTest\r\n{\r\n    class Program\r\n    {\r\n        static void Main()\r\n        {\r\n            //library uses one solver type (more will come if there will be demand): dense output stepper based on runge_kutta_dopri5 with standard error bounds 10^(-6) for the steps.\r\n            var solver = new Solver();\r\n\r\n            const double @from = 0.0;\r\n            const double to = 25.0;\r\n            const double step = 0.1;\r\n            //Say we have a class describing our system:\r\n            var myLorenz = new LorenzOde\r\n                {\r\n                    InitialConditions = new StateType(new[] { 10, 1.0, 1.0 })\r\n                };\r\n\r\n            // All we need to solve it:\r\n            solver.ConvenienceSolve(myLorenz, from, to, step);\r\n\r\n\r\n            //library class provides a simple to use Lambda API for ODE system defenition (example of lorenz, 50 steps)\r\n            var lorenz = new LambdaOde\r\n            {\r\n                InitialConditions = new StateType(new[] { 10, 1.0, 1.0 }),\r\n                OdeObserver = (x, t) => Console.WriteLine(\"{0} : {1} : {2}\", x[0], x[1], x[2]),\r\n                OdeSystem =\r\n                (x, dxdt, t) => {\r\n                    const double sigma = 10.0;\r\n                    const double r = 28.0;\r\n                    const double b = 8.0 / 3.0;\r\n                    dxdt[0] = sigma * (x[1] - x[0]);\r\n                    dxdt[1] = r * x[0] - x[1] - x[0] * x[2];\r\n                    dxdt[2] = -b * x[2] + x[0] * x[1];\r\n                }\r\n\r\n            };\r\n\r\n            // And all we need to solve it:\r\n            solver.ConvenienceSolve(lorenz, from, to, step);\r\n\r\n            // We can select stepper that our stepper would use\r\n            solver.StepperCode = StepperTypeCode.RungeKutta4;\r\n\r\n            // We can select how our IntegrateFunction will work: \r\n            solver.Solve(lorenz, from, step, to, IntegrateFunctionTypeCode.Adaptive);\r\n\r\n            // We can integrate for first N steps\r\n            solver.Solve(lorenz, from, step, 5 );\r\n\r\n            // Or at given time periods\r\n            solver.Solve(lorenz, new StateType(new[] { 0, 10.0, 100.0, 1000.0 }), step);\r\n\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nOr Windows Forms application example:\r\n![Windows Forms using ZedGraph   ODE solver Demo application](https://github.com/OlegJakushkin/CSharpOdeLibrary/blob/master/WinFormsODEGraphDemo.PNG?raw=true)\r\n\r\n```CSharp\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Drawing;\r\nusing System.Windows.Forms;\r\nusing OdeLibrary;\r\n\r\nnamespace OdeTestWF\r\n{\r\n    public partial class Form1 : Form\r\n    {\r\n        public Form1()\r\n        {\r\n            InitializeComponent();\r\n        }\r\n\r\n        private void Form1_Load(object sender, EventArgs e)\r\n        {\r\n            //library uses one solver type (more will come if there will be demand): dense output stepper based on runge_kutta_dopri5 with standard error bounds 10^(-6) for the steps.\r\n            var solver = new Solver();\r\n\r\n            var columns = new List<double>();\r\n            var rows = new List<double>();\r\n\r\n            //library class provides a simple to use Lambda API for ODE system defenition (example of lorenz, 50 steps)\r\n            var lorenz = new LambdaOde\r\n            {\r\n                From = 0,\r\n                To = 25,\r\n                Step = 0.1,\r\n                InitialConditions = new StateType(new[] { 10, 1.0, 1.0 }),\r\n                OdeObserver = \r\n                (x, t) => {\r\n                    columns.Add(x[0]);\r\n                    rows.Add(x[2]);\r\n                },\r\n                OdeSystem = \r\n                (x, dxdt, t) => {\r\n                    const double sigma = 10.0;\r\n                    const double r = 28.0;\r\n                    const double b = 8.0 / 3.0;\r\n                    dxdt[0] = sigma * (x[1] - x[0]);\r\n                    dxdt[1] = r * x[0] - x[1] - x[0] * x[2];\r\n                    dxdt[2] = -b * x[2] + x[0] * x[1];\r\n                }\r\n\r\n            };\r\n\r\n            // And all we need to solve it:\r\n            solver.ConvenienceSolve(lorenz);\r\n\r\n            //Draw ZedGraph\r\n            var graph = zg1;\r\n            var graphPane = zg1.GraphPane;\r\n            graphPane.Title.Text = \"Graph\";\r\n            graphPane.XAxis.Title.Text = \"x2\";\r\n            graphPane.YAxis.Title.Text = \"x0\";\r\n            graph.IsShowPointValues = true;\r\n\r\n            graphPane.AddCurve(\r\n                                     \"Lorenz\",\r\n                                     rows.ToArray(),\r\n                                     columns.ToArray(),\r\n                                     Color.CornflowerBlue);\r\n\r\n            graph.AxisChange();\r\n            graph.Invalidate();\r\n            graph.Refresh();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nHow to use OdeLibrary\r\n======================\r\n\r\n - Download latest repo.\r\n - Open folder Libraries\r\n - Add Project refrence to OdeLibrary.dll\r\n - Copy Core.dll into folder with your application\r\n\r\n\r\nThis is Utilety library because we do not support new Numeric Steppers or Integrate Functions Creation or any other type of OdeInt library extension.\r\n\r\nWhat parts of Boost.OdeInt we do provide:\r\n-----------------------------------------\r\n\r\nSteppers [description of all Steppers in C++ OdeInt][1]:\r\n - Euler,\r\n - ModifiedMidpoint,\r\n - RungeKutta4,\r\n - RungeKuttaCashKarp54,\r\n - RungeKuttaDopri5,\r\n - RungeKuttaFehlberg78,\r\n - ControlledRungeKutta,\r\n - BulirschStoer,\r\n - BulirschStoerDenseOut,\r\n\r\nAnd Integrate Functions [description of all Integrate Functions in C++ OdeInt][2]:\r\n - Const,\r\n - Adaptive\r\n\r\nWe also support N first steps integration:\r\n```CSharp\r\n    solver.Solve(ode, from, step, constStepsAmmount );\r\n```\r\n\r\nAs wall as integration at given time points:\r\n```CSharp\r\n    solver.Solve(ode, new StateType(new[] { 0, 10.0, 100.0, 1000.0 }), step);\r\n```\r\n\r\n*[Demonstration Windows Forms Solution][3]:*\r\n\r\n![Windows Forms using ZedGraph   ODE solver Demo application](https://github.com/OlegJakushkin/CSharpOdeLibrary/blob/master/WinFormsODEGraphDemo.PNG?raw=true)\r\n![Windows Forms using ZedGraph   ODE solver Demo application](https://github.com/OlegJakushkin/CSharpOdeLibrary/blob/master/WinFormsODEGraphDemoDefaultSolver.PNG?raw=true)\r\n\r\n\r\n  [1]: http://www.boost.org/doc/libs/1_53_0/libs/numeric/odeint/doc/html/boost_numeric_odeint/odeint_in_detail/steppers.html\r\n  [2]: http://www.boost.org/doc/libs/1_53_0/libs/numeric/odeint/doc/html/boost_numeric_odeint/odeint_in_detail/integrate_functions.html\r\n  [3]: https://github.com/OlegJakushkin/CSharpOdeLibrary/releases/tag/v1.0\r\n","google":"UA-48866054-1","note":"Don't delete this file! It's used internally to help with page regeneration."}